<!DOCTYPE html>
<html>
<head>
    <title>Mouse Dodge Game</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        canvas { display: block; background-color: black; }
        #hpBar {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <img id="shurikenSprite" src="/static/sprites/shuriken.png" style="display: none;">
    <div id="hpBar">HP: 100</div>
    <div id="bossBar" style="position: absolute; top: 40px; left: 10px; color: red; font-family: sans-serif; font-weight: bold;">
        Boss HP: 1000
    </div>
    <div id="keywordsContainer" style="position: absolute; bottom: 10px; left: 10px; color: white; font-family: sans-serif; font-size: 18px;">
        <!-- Keywords will appear here -->
    </div>
<canvas id="gameCanvas"></canvas>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const slashes = [];
    const lasers = [];


    class Player {
        constructor() {
            this.hp = 100;
        }

        takeDamage(amount) {
            // Do not update HP locally, only send damage to server
            sendDamageToServer(amount);
        }
    }

    let bossHealth = 1000;
    const bossBar = document.getElementById('bossBar');
    const keywordsContainer = document.getElementById('keywordsContainer');
    let keywordsData = {};

    // Fetch boss info from server
    async function fetchBoss() {
        const response = await fetch('/api/boss');
        const data = await response.json();
        bossHealth = data.health;
        updateBossBar();
    }

    // Fetch keywords from words.json
    async function fetchKeywords() {
        const response = await fetch('/static/words.json');
        keywordsData = await response.json();
    }

    // Update boss HP display
    function updateBossBar() {
        bossBar.innerText = `Boss HP: ${bossHealth}`;
    }

    // Display all keywords
    function displayKeywords() {
        keywordsContainer.innerHTML = '';
        for (const group in keywordsData) {
            const words = keywordsData[group].word;
            words.forEach(word => {
                const wordElem = document.createElement('span');
                wordElem.innerText = word;
                wordElem.style.marginRight = '15px';
                wordElem.style.cursor = 'pointer';
                wordElem.style.userSelect = 'none';
                wordElem.style.padding = '5px 10px';
                wordElem.style.border = '1px solid white';
                wordElem.style.borderRadius = '5px';
                wordElem.style.display = 'inline-block';
                wordElem.style.transition = 'background-color 0.3s';
                wordElem.addEventListener('mouseenter', () => {
                    wordElem.style.backgroundColor = 'rgba(255,255,255,0.2)';
                });
                wordElem.addEventListener('mouseleave', () => {
                    wordElem.style.backgroundColor = 'transparent';
                });
                wordElem.addEventListener('click', () => {
                    handleKeywordClick(group, word);
                });
                keywordsContainer.appendChild(wordElem);
            });
        }
    }

    // Handle keyword click
    async function handleKeywordClick(group, word) {
        // Check if clicked word is the correct keyword for the boss
        if (boss.key_word && boss.key_word[group] && boss.key_word[group].includes(word)) {
            // Send damage to boss
            const damageAmount = 50; // Arbitrary damage value
            const response = await fetch('/api/boss/damage', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({damage: damageAmount})
            });
            const data = await response.json();
            bossHealth = data.health;
            updateBossBar();
            if (data.defeated) {
                alert('Boss defeated! Returning to home page.');
                window.location.href = '/home';
            }
        } else {
            // Wrong keyword clicked, maybe do nothing or feedback
            alert('Wrong keyword!');
        }
    }

    // Initialize boss object locally for checking keywords
    let boss = {
        key_word: {}
    };

    // Initialize game additions
    async function initGameBoss() {
        await fetchBoss();
        await fetchKeywords();
        boss.key_word = keywordsData;
        displayKeywords();
        setInterval(() => {
            displayKeywords();
        }, 15000);
    }

    initGameBoss();

    class ProjectileAttack {
        constructor(name, damage, speed, x, y, targetX, targetY, sprite) {
            this.name = name;
            this.damage = damage;
            this.speed = speed;
            this.x = x;
            this.y = y;
            this.radius = 10; // for collision
            this.sprite = sprite;
            this.rotation = 0;

            // Compute angle to player at time of spawn
            const dx = targetX - x;
            const dy = targetY - y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            this.vx = (dx / distance) * speed;
            this.vy = (dy / distance) * speed;
        }

        move() {
            this.x += this.vx;
            this.y += this.vy;
            this.rotation += 0.2; // Rotate every frame
        }

        isCollidingWith(px, py, pr) {
            const dx = this.x - px;
            const dy = this.y - py;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < this.radius + pr;
        }

        draw(ctx) {
            const size = 30;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.drawImage(this.sprite, -size / 2, -size / 2, size, size);
            ctx.restore();
        }
    }




    class SlashAttack {
        constructor(name, damage, x, y, width, height, duration) {
            this.name = name;
            this.damage = damage;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.duration = duration; // in ms
            this.startTime = performance.now();
        }

        isActive() {
            return performance.now() - this.startTime < this.duration;
        }

        isCollidingWith(px, py, pr) {
            return this.isActive() &&
                px + pr > this.x &&
                px - pr < this.x + this.width &&
                py + pr > this.y &&
                py - pr < this.y + this.height;
        }

        draw(ctx) {
            if (this.isActive()) {
                ctx.fillStyle = 'orange';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }
    }

    class LaserBeamAttack {
        constructor(name, damage, x, width, duration) {
            this.name = name;
            this.damage = damage;
            this.x = x;
            this.width = width;
            this.y = 0;
            this.height = canvas.height;
            this.duration = duration;
            this.startTime = performance.now();
        }

        isActive() {
            return performance.now() - this.startTime < this.duration;
        }

        isCollidingWith(px, py, pr) {
            return this.isActive() &&
                px + pr > this.x &&
                px - pr < this.x + this.width;
        }

        draw(ctx) {
            if (this.isActive()) {
                ctx.fillStyle = 'cyan';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }
    }


    const player = new Player();
    let playerX = canvas.width / 2;
    let playerY = canvas.height / 2;
    const playerRadius = 10;
    const bullets = [];

    document.addEventListener('mousemove', (e) => {
        playerX = e.clientX;
        playerY = e.clientY;
    });

    function spawnShurikenFromBorder() {
        const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
        let x, y;

        if (side === 0) { // Top
            x = Math.random() * canvas.width;
            y = -20;
        } else if (side === 1) { // Right
            x = canvas.width + 20;
            y = Math.random() * canvas.height;
        } else if (side === 2) { // Bottom
            x = Math.random() * canvas.width;
            y = canvas.height + 20;
        } else { // Left
            x = -20;
            y = Math.random() * canvas.height;
        }

        bullets.push(new ProjectileAttack(
            "shuriken",
            1,
            3,
            x,
            y,
            playerX,
            playerY,
            document.getElementById("shurikenSprite")
        ));
    }


    function updateHPBar(hp) {
        document.getElementById("hpBar").innerText = `HP: ${hp}`;
    }

    setInterval(spawnShurikenFromBorder, 60);

    setInterval(() => {
    if (Math.random() < 0.5) {
        slashes.push(new SlashAttack("slash", 1, Math.random() * canvas.width, canvas.height - 100, 100, 20, 500));
    } else {
        lasers.push(new LaserBeamAttack("laser", 1, Math.random() * canvas.width, 20, 800));
    }
    }, 4000);


    function sendDamageToServer(amount) {
        fetch('/api/player/hp', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({damage: amount})
        }).then(res => res.json()).then(data => {
            // Update HP bar only from server response
            updateHPBar(data.hp);
            // Update local player HP to server authoritative HP
            player.hp = data.hp;
            // Redirect to index.html if HP is 0 or less
            if (player.hp <= 0) {
                window.location.href = '/home';
            }
        });
    }

    function update() {
        bullets.forEach(b => b.move());

        bullets.forEach(b => {
            if (b.isCollidingWith(playerX, playerY, playerRadius)) {
                player.takeDamage(b.damage);
                bullets.splice(bullets.indexOf(b), 1);
            }
        });

        slashes.forEach(s => {
            if (s.isCollidingWith(playerX, playerY, playerRadius)) {
                player.takeDamage(s.damage);
            }
        });

        lasers.forEach(l => {
            if (l.isCollidingWith(playerX, playerY, playerRadius)) {
                player.takeDamage(l.damage);
            }
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw player
        ctx.beginPath();
        ctx.arc(playerX, playerY, playerRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();

        // Draw bullets
        bullets.forEach(b => b.draw(ctx));

        // Draw slashes and lasers
        slashes.forEach(s => s.draw(ctx));
        lasers.forEach(l => l.draw(ctx));
    }



    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
        console.log(player.hp)
    }
    loop();
</script>
</body>
</html>
