<!DOCTYPE html>
<html>
<head>
    <title>Mouse Dodge Game</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        canvas { display: block; background-color: black; }
        #hpBar {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <img id="shurikenSprite" src="/static/images/shuriken.png" style="display: none;">
    <div id="hpBar">HP: 100</div>
<canvas id="gameCanvas"></canvas>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const slashes = [];
    const lasers = [];


    class Player {
        constructor() {
            this.hp = 100;
        }

        takeDamage(amount) {
            this.hp -= amount;
            if (this.hp < 0) this.hp = 0;
            updateHPBar(this.hp);
            sendDamageToServer(amount);
        }
    }

    class ProjectileAttack {
        constructor(name, damage, speed, x, y, targetX, targetY, sprite) {
            this.name = name;
            this.damage = damage;
            this.speed = speed;
            this.x = x;
            this.y = y;
            this.radius = 10; // for collision
            this.sprite = sprite;
            this.rotation = 0;

            // Compute angle to player at time of spawn
            const dx = targetX - x;
            const dy = targetY - y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            this.vx = (dx / distance) * speed;
            this.vy = (dy / distance) * speed;
        }

        move() {
            this.x += this.vx;
            this.y += this.vy;
            this.rotation += 0.2; // Rotate every frame
        }

        isCollidingWith(px, py, pr) {
            const dx = this.x - px;
            const dy = this.y - py;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < this.radius + pr;
        }

        draw(ctx) {
            const size = 30;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.drawImage(this.sprite, -size / 2, -size / 2, size, size);
            ctx.restore();
        }
    }




    class SlashAttack {
        constructor(name, damage, x, y, width, height, duration) {
            this.name = name;
            this.damage = damage;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.duration = duration; // in ms
            this.startTime = performance.now();
        }

        isActive() {
            return performance.now() - this.startTime < this.duration;
        }

        isCollidingWith(px, py, pr) {
            return this.isActive() &&
                px + pr > this.x &&
                px - pr < this.x + this.width &&
                py + pr > this.y &&
                py - pr < this.y + this.height;
        }

        draw(ctx) {
            if (this.isActive()) {
                ctx.fillStyle = 'orange';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }
    }

    class LaserBeamAttack {
        constructor(name, damage, x, width, duration) {
            this.name = name;
            this.damage = damage;
            this.x = x;
            this.width = width;
            this.y = 0;
            this.height = canvas.height;
            this.duration = duration;
            this.startTime = performance.now();
        }

        isActive() {
            return performance.now() - this.startTime < this.duration;
        }

        isCollidingWith(px, py, pr) {
            return this.isActive() &&
                px + pr > this.x &&
                px - pr < this.x + this.width;
        }

        draw(ctx) {
            if (this.isActive()) {
                ctx.fillStyle = 'cyan';
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }
    }


    const player = new Player();
    let playerX = canvas.width / 2;
    let playerY = canvas.height / 2;
    const playerRadius = 10;
    const bullets = [];

    document.addEventListener('mousemove', (e) => {
        playerX = e.clientX;
        playerY = e.clientY;
    });

    function spawnShurikenFromBorder() {
        const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
        let x, y;

        if (side === 0) { // Top
            x = Math.random() * canvas.width;
            y = -20;
        } else if (side === 1) { // Right
            x = canvas.width + 20;
            y = Math.random() * canvas.height;
        } else if (side === 2) { // Bottom
            x = Math.random() * canvas.width;
            y = canvas.height + 20;
        } else { // Left
            x = -20;
            y = Math.random() * canvas.height;
        }

        bullets.push(new ProjectileAttack(
            "shuriken",
            10,
            3,
            x,
            y,
            playerX,
            playerY,
            document.getElementById("shurikenSprite")
        ));
    }


    function updateHPBar(hp) {
        document.getElementById("hpBar").innerText = `HP: ${hp}`;
    }

    setInterval(spawnShurikenFromBorder, 600);

    setInterval(() => {
    if (Math.random() < 0.5) {
        slashes.push(new SlashAttack("slash", 15, Math.random() * canvas.width, canvas.height - 100, 100, 20, 500));
    } else {
        lasers.push(new LaserBeamAttack("laser", 25, Math.random() * canvas.width, 20, 800));
    }
    }, 4000);


    function sendDamageToServer(amount) {
        fetch('/api/player/hp', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({damage: amount})
        }).then(res => res.json()).then(data => {
            updateHPBar(data.hp);
        });
    }

    function update() {
        bullets.forEach(b => b.move());

        bullets.forEach(b => {
            if (b.isCollidingWith(playerX, playerY, playerRadius)) {
                player.takeDamage(b.damage);
                bullets.splice(bullets.indexOf(b), 1);
            }
        });

        slashes.forEach(s => {
            if (s.isCollidingWith(playerX, playerY, playerRadius)) {
                player.takeDamage(s.damage);
            }
        });

        lasers.forEach(l => {
            if (l.isCollidingWith(playerX, playerY, playerRadius)) {
                player.takeDamage(l.damage);
            }
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw player
        ctx.beginPath();
        ctx.arc(playerX, playerY, playerRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();

        // Draw bullets
        bullets.forEach(b => b.draw(ctx));

        // Draw slashes and lasers
        slashes.forEach(s => s.draw(ctx));
        lasers.forEach(l => l.draw(ctx));
    }



    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    setInterval(spawnBullet, 400);
    loop();
</script>
</body>
</html>
